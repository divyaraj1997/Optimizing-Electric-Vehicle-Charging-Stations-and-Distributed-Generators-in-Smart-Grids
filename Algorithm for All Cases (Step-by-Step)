MATLAB code explained in simple and easy terms step-by-step with what each part does.

##  Function Name and Inputs
matlab Copy Edit
function [obj] = evuci1(pv)
Function name: evuci1

Input: pv ‚Äî a matrix where:

pv(:,1:8) = location of EVCS and DGs (rounded to nearest integer)

üìçPart 1: Initialization
matlab Copy Edit
ns = size(pv,1);  % number of candidate solutions (rows in input)
obj = zeros(ns,1); % initialize the objective value array
best_w1 = zeros(ns,1); % (not used now)
best_w2 = zeros(ns,1); % (not used now)

evloc = round(pv)); % EVCS locations
loc = round(pv);   % DG locations
rat = round(pv));   % DG ratings

üöó Part 2: EV Consumer Cost Index (EVCCI) Calculation
matlab Copy Edit

evd = load('EV_data.m');  % load EV demand data
rn = evd(:,1);     % road node numbers
nev = evd(:,2);    % number of EVs at each node
dmin = evd(:,3);   % min travel distance to EVCS
dmax = evd(:,4);   % max travel distance to EVCS
‚ûï Then calculates:
matlab Copy Edit
evucimin = dmin(evloc(:,1))*nev(evloc(:,1))+...
           dmin(evloc(:,4))*nev(evloc(:,4));

evucimax = dmax(evloc(:,1))*nev(evloc(:,1)) + ...
           dmax(evloc(:,4))*nev(evloc(:,4));

obj1 = evucimin ./ evucimax;  % normalized consumer inconvenience index
üìå This gives us how inconvenient (cost-wise) it is for EV users to reach a charging station.

‚ö° Part 3: Real Power Loss Index (RPLI)
matlab Copy Edit

LD = load('linedata33.m');  % line data (from bus, to bus, resistance, reactance)
BD = load('busdata_33.m');  % bus data (bus no, Pd, Qd)

‚ûï Modify bus data to add DG generation at selected buses:
matlab Copy Edit

BD(loc(:,i),2) = BD(loc(:,i),2) - real(rat(:,i));  % reduce real demand
BD(loc(:,i),3) = BD(loc(:,i),3) - imag(rat(:,i));  % reduce reactive demand
(Repeated for i = 1 to 4)

üîå Add EVCS Load: matlab Copy Edit

BD(evloc(1,1),2) = BD(evloc(1,1),2);+...
BD(evloc(1,4),2) = BD(evloc(1,4),2);

‚úÖ This means you're simulating both DG generation and EVCS loads in the system.
 üìê Part 4: Convert to Per Unit System (PU)
matlab Copy Edit

MVAb = 100;
KVb = 12.66;
Zb = (KVb^2)/MVAb;

Rpu = R/Zb;
Xpu = X/Zb;
Ppu = Pd/(1000 * MVAb);
Qpu = Qd/(1000 * MVAb);
‚úÖ PU system simplifies calculations in power systems by normalizing values.

üîÑ Part 5: Load Flow using Backward/Forward Sweep
Uses a while-loop to run backward-forward sweep method until voltage error < 0.0001

Calculates voltage at each bus and line currents . Iteratively updates bus voltages

üîª Part 6: Calculate Real Power Loss
matlab Copy Edit

Rp = abs(Iline.^2).*Rpu;  % power loss per line
rp = sum(abs(Rp));        % total power loss
Plosskw = rp * 100000;    % convert to kW
obj2 = 1 - (Plosskw base/ Plosskw); % normalize with base loss

‚úÖ This gives a power loss index ‚Äî lower power loss gives better performance.

üéØ Part 7: Final Objective Function
matlab Copy Edit

obj = (w1 * obj1) + (w2 * obj2);  % weighted multi-objective value
‚úÖ The lower the obj, the better the combined result of low power loss and low EV user cost.

üí° Summary of What This Code Does:
Component	Purpose
pv input	Contains locations and ratings for DG and EVCS
obj1	EV Consumer Cost Index (minimize inconvenience)
obj2	Power Loss Index (minimize real power losses)
Load Flow	Calculates bus voltages and line flows
obj output	Combined cost function using weights (w1, w2)

%%%%%%%%%%%%%%%%%%%%%%%%%%%% code %%%%%%%%%%%%%%%%%%%%
clc;
clear all;

% ---------- Initialization ----------
j = sqrt(-1);          % complex unit
wmax = 0.9;            % max inertia weight (PSO)
wmin = 0.4;            % min inertia weight (PSO)
c1 = 2;                % cognitive learning factor
c2 = 2;                % social learning factor

% Define lower and upper bounds for variables
% First 4: EVCS locations, Next 4: DG sizes (indexes & values)
lb,ub;
ns = 100;             % number of particles (solutions)
nv = size(lb,2);      % number of decision variables
nite = 100;           % max number of iterations
tol = 0.001;        % stopping tolerance

% ---------- Random Initialization ----------
r1 = rand(ns, nv);              % random values for scaling
pv = round(convert_pv(lb, ub, ns));  % initial population
fprev = zeros(ns,1);            % store previous fitness
ite = 1;                        % iteration counter
alpha = 1;                      % convergence indicator

% ---------- Optimization Loop ----------
while alpha > tol

    % Evaluate objective function
    obj = evuci1(pv);                % hybrid objective function (EVCCI + Power Loss)
    pvobj = [pv obj];                % combine parameters and fitness

    % ------ TEACHER PHASE (TLBO) ------
    [tpvobj] = teacherh(pvobj, lb, ub);  % teacher phase output

    % ------ PSO INITIALIZATION ------
    vel = 0.1 .* pv;               % initialize velocities
    f0 = evuci1(pv);               % initial fitness
    sol0 = [pv f0];                % store initial solution
    [fmin0, index0] = min(f0);     % find global best
    pbest = pv;                    % personal best
    gbest = pv(index0,:);         % global best

    % ------ PSO UPDATE LOOP ------
    w = wmax - ((wmax - wmin) * ite / nite);  % update inertia weight

    for i = 1:ns
        for j = 1:nv
            vel(i,j) = round(w*vel(i,j) ...
                        + c1*rand()*(pbest(i,j)-pv(i,j)) ...
                        + c2*rand()*(gbest(1,j)-pv(i,j)));
            pv(i,j) = round(pv(i,j) + vel(i,j));
        end
    end

    % Boundary check
    for i = 1:ns
        for j = 1:nv
            if pv(i,j) < lb(j) || pv(i,j) > ub(j)
                pv(i,j) = round(lb(j) + rand() * (ub(j) - lb(j)));
            end
        end
    end

    % ------ PSO FITNESS EVALUATION ------
    f1 = evuci1(pv);
    sol1 = [pv f1];

    % Update pbest
    for i = 1:ns
        if f1(i) < f0(i)
            pbest(i,:) = pv(i,:);
            f0(i) = f1(i);
        end
    end

    % Update gbest
    [fminupd, index] = min(f0);
    best(ite,:) = fminupd;
    if fminupd < fmin0
        gbest = pbest(index,:);
        fmin0 = fminupd;
    end

    % ------ MERGE BEST SOLUTIONS FROM TLBO AND PSO ------
    upd1 = sortrows(tpvobj, 1+nv);      % sort TLBO output by fitness
    upd2 = sortrows([pbest f0], 1+nv);  % sort PSO output by fitness

    btp = upd1(1:ns/2,:);   % top 50% from TLBO
    bpso = upd2(1:ns/2,:);  % top 50% from PSO

    finres = [btp; bpso];   % combine both best halves

    % ------ LEARNER PHASE (TLBO) ------
    [lpvobj] = learner1(finres, lb, ub);   % apply learner phase
    srt1 = sortrows(lpvobj, 1+nv);         % sort learners
    obj = srt1(:,1+nv);                    % new objective values

    % ------ CONVERGENCE CHECK ------
    fpres = obj;
    alpha = min(abs(fpres - fprev));  % difference from previous iteration
    fprev = fpres;
    ite = ite + 1;
end

% Final best solution after all iterations
bst = srt1(1,:);
disp('Best solution:');
disp(bst);
